<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: daos/impl/redis/scripts/findAll_script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: daos/impl/redis/scripts/findAll_script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { redisClient } from '../redisClient.js'
import { getPostIDsKey } from '../redis_key_generator.js'

const script = `
    --
    -- Get an table of all post hash.
    -- @param {string} KEYS[1] - The key to operate on. 
    -- @returns {table} The table of all post hash.
    -- 
    local key = KEYS[1]
    local ids = redis.call('ZRANGE', key,  0, -1)
    local hash = {}
    local posts = {}

    for i = 1, #ids do
        hash = redis.call('HGETALL', ids[i])
        table.insert(posts, hash)
    end
    return posts
`
/**
 * Load lua script for findAllWithLua
 *
 * @returns {null} 
 */
const load = async () => {
  redisClient.defineCommand("myfunc", {
    numberOfKeys: 1,
    lua: script,
  });  
};

/**
 * Get an array of array of all posts objects using Lua script. 
 *
 * @returns {Promise} - a Promise, resolving to an array of array of posts.
 */
const findAllWithLua = () => {  
  return redisClient.myfunc(getPostIDsKey())
}
  
export { load, findAllWithLua };

/*
ioredis | Lua Scripting
https://github.com/redis/ioredis

ioredis supports all of the scripting commands such as EVAL, EVALSHA and SCRIPT. 
However, it's tedious to use in real world scenarios since developers have to take 
care of script caching and to detect when to use EVAL and when to use EVALSHA. 
ioredis exposes a defineCommand method to make scripting much easier to use:

const redis = new Redis();

// This will define a command myecho:
redis.defineCommand("myecho", {
  numberOfKeys: 2,
  lua: "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}",
});

// Now `myecho` can be used just like any other ordinary command,
// and ioredis will try to use `EVALSHA` internally when possible for better performance.
redis.myecho("k1", "k2", "a1", "a2", (err, result) => {
  // result === ['k1', 'k2', 'a1', 'a2']
});

// `myechoBuffer` is also defined automatically to return buffers instead of strings:
redis.myechoBuffer("k1", "k2", "a1", "a2", (err, result) => {
  // result[0] equals to Buffer.from('k1');
});

// And of course it works with pipeline:
redis.pipeline().set("foo", "bar").myecho("k1", "k2", "a1", "a2").exec();

*/</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addNumbers">addNumbers</a></li><li><a href="global.html#addNumbersAsync">addNumbersAsync</a></li><li><a href="global.html#del">del</a></li><li><a href="global.html#disconnect">disconnect</a></li><li><a href="global.html#findAll">findAll</a></li><li><a href="global.html#findAllWithLua">findAllWithLua</a></li><li><a href="global.html#findById">findById</a></li><li><a href="global.html#getPostHashKey">getPostHashKey</a></li><li><a href="global.html#getPostIDsKey">getPostIDsKey</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadDao">loadDao</a></li><li><a href="global.html#redisClient">redisClient</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Fri Aug 16 2024 16:43:24 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
